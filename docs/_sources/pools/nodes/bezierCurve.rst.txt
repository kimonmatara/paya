******************************
paya.runtime.nodes.BezierCurve
******************************

.. py:currentmodule:: paya.runtime.nodes

.. py:class:: BezierCurve(*args, **kwargs)

    .. py:classmethod:: create(*points, name=None, under=None, displayType=None, conformShapeName=True, intermediate=False, lineWidth=None)
    
        Bezier curve constructor. Points can be static or dynamic.
        
        :param \*points: if provided, the number of CV points must be 'legal'
            for a Bezier curve; namely, outer anchors must receive two CVs
            each, and inner anchors must each receive three CVs; if omitted,
            an empty Bezier curve shape node will be createds
        :param \*points: None, str, tuple, list,
            :class:`~paya.runtime.data.Point`,
            :class:`~paya.runtime.plugs.Vector`
        :param name/n: one or more name elements; defaults to None
        :type name/n: str, int, None, tuple, list
        :param under/u: an optional destination parent; no space conversion
            will take place; if the parent has transforms, the curve shape
            will be transformed as well; defaults to None
        :type under/u: None, str, :class:`~paya.runtime.nodes.Transform`
        :param displayType/dt: if provided, an index or enum label:
        
            - 0: 'Normal'
            - 1: 'Template'
            - 2: 'Reference'
        
            If omitted, display overrides won't be activated at all.
        :type displayType/dt: None, int, str
        :param bool conformShapeName/csn: if reparenting, rename the shape to
            match the destination parent; defaults to True
        :param bool intermediate: set the shape to intermediate; defaults to
            False
        :param lineWidth/lw: an override for the line width; defaults to None
        :type lineWidth/lw: None, float
        :return: The curve shape.
        :rtype: :class:`BezierCurve`
    
    .. py:method:: numAnchors()
    
        :return: The number of anchors on this bezier curve.
        :rtype: int
    
    .. py:method:: paramAtAnchor(anchorIndex)
    
        This is a fixed calculation, since anchors always 'touch' the curve at
        same parameter.
        
        :param int anchorIndex: the anchor index
        :return: The U parameter.
    
    .. py:method:: getCVsAtAnchor(anchorIndex, asComponents=False, asPoints=False, asIndices=False, plug=False)
    
        Note that, unlike Maya's standard
        :meth:`~pymel.core.nodetypes.NurbsCurve.getCVs`, this returns
        components, not points.
        
        :param int anchorIndex: the index of the anchor to inspect
        :param bool asComponents/ac: return instances of
            :class:`~paya.runtime.comps.NurbsCurveCV`; defaults to False
        :param bool asIndices/ai: return CV indices; defaults to False
        :param bool asPoints/ap: return world positions; defaults to True
        :param bool plug/p: if *asPoints* is requested, return attributes,
            not values; defaults to False
        :return: The control vertices at the given anchor.
        :rtype: [:class:`~paya.runtime.components.NurbsCurveCV`]
    
    .. py:method:: getControlPoints(anchors=False, plug=False, worldSpace=False)
    
        Overloads :meth:`paya.runtime.nodes.NurbsCurve.getControlPoints` to
        add the *anchors* / *a* option.
        
        :param bool anchors/a: organise the return into bezier anchor groups;
            see :func:`paya.lib.nurbsutil.itemsAsBezierAnchors`; defaults to
            False
        :param bool plug/p: force a dynamic output; defaults to False
        :param bool worldSpace/ws: return world-space points; defaults to
            False
        :return: The control points.
        :rtype: [:class:`~paya.runtime.plugs.Vector`],
            [:class:`~paya.runtime.data.Point`]
            [dict]
    
    .. py:method:: matrixAtAnchor(anchorIndex, tangentAxis, upAxis, upVector=None, aimCurve=None, closestPoint=True, globalScale=None, squashStretch=False, plug=False)
    
        :param int anchorIndex: the anchor index
        :param str tangentAxis: the axis to map to the anchor tangent,
            for example '-y'
        :param str upAxis: the axis to map to the resolve up vector,
            for example 'x'
        :param upVector/upv: an explicit up vector; defaults to None
        :type upVector/upv: None, tuple, list, str,
            :class:`~paya.runtime.data.Vector`,
            :class:`~paya.runtime.plugs.Vector`
        :param aimCurve/aic: an aim curve to derive up vectors from;
            defaults to None
        :type aimCurve/aic: None, str, :class:`~paya.runtime.nodes.Transform`,
            :class:`~paya.runtime.nodes.NurbsCurve`,
            :class:`~paya.runtime.plugs.NurbsCurve`
        :param bool closestPoint/cp: pull points from the aim curve based on
            proximity, not matched parameter; defaults to True
        :param globalScale/gs: ignored if not a plug; a baseline scalar;
            defaults to None
        :type globalScale/gs: None, str, float,
            :class:`~paya.runtime.plugs.Math1D`
        :param bool squashStretch/ss: allow squash-and-stretch on the tangent
            vector; defaults to False
        :param bool plug/p: force a dynamic output; defaults to False
        :return: A matrix at the specified anchor.
        :rtype: :class:`~paya.runtime.plugs.Matrix`,
            :class:`~paya.runtime.data.Matrix`
    
    .. py:method:: clusterAll(merge=False, tolerance=1e-06, anchors=False)
    
        Overloads :meth:`~paya.runtime.nodes.NurbsCurve.clusterAll` to add the
        *anchors* / *a* option.
        
        :param bool anchors/a: group clusters by bezier anchor; defaults to
            False
        :param bool merge/mer: merge CVs if they overlap within the specified
            *tolerance*; defaults to False
        :param float tolerance/tol: the merging tolerance; defaults to 1e-6
        :return: The clusters.
        :rtype: [:class:`~paya.runtime.nodes.Cluster`]