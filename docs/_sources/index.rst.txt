Paya: PyMEL for Riggers
=======================

Paya is an object-oriented toolkit for Maya riggers. Unlike other libraries, it doesn't re-wrap ``maya.cmds`` or the
`OpenMaya <https://help.autodesk.com/view/MAYAUL/2023/ENU/?guid=Maya_SDK_Maya_Python_API_html>`_ API. Instead, it adds
functionality to `PyMEL <https://help.autodesk.com/view/MAYAUL/2022/ENU/?guid=__PyMel_index_html>`_ types at runtime
for an integrated and familiar experience.

Included is the most comprehensive, and intuitive, implementation of :doc:`maths rigging using Python operators
<maths_rigging>` available anywhere, with over 100 methods for linear algebra, trigonometry and more.

Customisation is easy, and goes far beyond PyMEL's
`virtual classes <https://github.com/LumaPictures/pymel/blob/master/examples/customClasses.py>`_ system to add support
for attribute (including subtype), component and data types with true inheritance for the first time.

.. admonition:: New in version 0.8

    .. rubric:: Total Curve Madness

    *   Extensive :doc:`sampling and editing methods on NURBS and Bezier curve shapes, plugs and components
        <curves>`.
    *   :ref:`Complete curve framing <curve_framing>`: extract dynamic and static matrices from any point, parameter,
        length or fraction of a NURBS or Bezier curve.
    *   :ref:`Distribute joints and drive chains <curve_distributions>` with ease; control up vectors explicitly or with
        aim curves.
    *   :ref:`True, evaluated curve length locking <length_locking>`.
    *   Use plug methods to :ref:`work fully procedurally in the DG <procedural_geo_editing>` and only create shapes
        where you need them.
    *   :ref:`Create two- and three-point circular arcs that won't disappear with an error when the input points
        are in-line <arcs>`.
    *   Use :meth:`~paya.runtime.nodes.NurbsCurve.clusterAll` to cluster-up curves with automatic merging of overlapping
        CVs.
    *   Options to manage line widths added to the control shape methods and elsewhere.

    .. rubric:: Across the Board

    *   A standard constructor and smart editing methods for :class:`cluster <paya.runtime.nodes.Cluster>` deformers.
    *   A standard constructor for :class:`curveWarp <paya.runtime.nodes.CurveWarp>` deformers.
    *   New ``maintainOffset/mo`` and ``worldSpace`` options for :meth:`~paya.runtime.plugs.Matrix.decomposeAndApply`,
        and a dedicated :meth:`~paya.runtime.plugs.Matrix.applyViaOpm` method
    *   New methods to :ref:`manage procedural history edits <procedural_geo_editing>` in Maya-standard ways:
        :meth:`~paya.runtime.nodes.DeformableShape.getOrigPlug`,
        :meth:`~paya.runtime.nodes.DeformableShape.getHistoryPlug`,
        :meth:`~paya.runtime.nodes.DeformableShape.deleteHistory` and
        :meth:`~paya.runtime.plugs.Geometry.getShapeMFn`
    *   New maths methods: :meth:`~paya.runtime.plugs.Math1D.gatedClamp`,
        :meth:`~paya.runtime.plugs.Vector.asShearMatrix`,
        :meth:`~paya.runtime.plugs.Vector.projectOnto` and
        :meth:`~paya.runtime.plugs.Vector.rejectFrom`
    *   :doc:`And more! <whats_new>`


Example #1: Worm Rig
--------------------

This rig features two bezier tangent controls, per-anchor twist, pick-walking and squash-and-stretch with triggered
blend shapes and bump map. The layout scene can be found here: ``paya/examples/worm_rig_layout.ma``. The build method is
defined inside :mod:`paya.examples.worm_rig`.

.. tabs::

    .. tab:: Viewport

        .. figure:: worm_rig.gif
            :align: center

    .. tab:: Run Call

        .. code-block:: python

            import paya.examples.worm_rig as wr

            with r.Name('worm'):
                wr.createWormRig('locator1', 'locator2',
                    16, 'base', 'squashed', 'stretched')

    .. tab:: Paya

        .. code-block:: python

            import paya.runtime as r

            def createWormRig(
                    startLoc,
                    endLoc,
                    numJoints,
                    baseMesh,
                    squashMesh,
                    stretchMesh
            ):
                # Get layout information
                startPoint = r.PyNode(startLoc).getWorldPosition()
                endPoint = r.PyNode(endLoc).getWorldPosition()
                spineVector = (endPoint-startPoint)

                # Draw the curves
                points = [startPoint+(spineVector * (1/3 * i)) for i in range(4)]

                spineCurve = r.nodes.BezierCurve.create(points, name='main').getParent()
                aimCurve = spineCurve.duplicate(name='aim', managedNames=True)[0]
                aimCurve.attr('translateY').set(1.5)
                aimCurve.makeIdentity(apply=True)

                # Draw controls, drive the curves
                controls = []

                for anchorIndex in (0, 1):
                    matrix = spineCurve.matrixAtAnchor(anchorIndex, 'z', 'x', upv=[0,1,0])

                    with r.Name(anchorIndex+1):
                        control = r.createControl(
                            worldMatrix=matrix,
                            pickWalkParent=controls[-1] if controls else None,
                            keyable=['translate', 'rotate', 'scaleZ'],
                            color=6,
                            size=1.25,
                            lineWidth=2.0,
                            rotateOrder='zxy' # for easier twist control
                        )

                        cvs = spineCurve.getCVsAtAnchor(anchorIndex, asComponents=True)
                        cvs += aimCurve.getCVsAtAnchor(anchorIndex, asComponents=True)
                        r.nodes.Cluster.create(cvs, handle=control, maintainOffset=True)

                        controls.append(control)

                # Driven blend shapes
                blend = r.nodes.BlendShape.create(baseMesh, pre=True)
                squashed = blend.targets.add(squashMesh)
                stretched = blend.targets.add(stretchMesh)

                squashStretchRatio = spineCurve.length(
                    plug=True) / spineCurve.length()

                squashDriver = squashStretchRatio.remap(1.0, 0.75, 0.0, 1.0)
                squashDriver >> squashed.weight

                stretchDriver = squashStretchRatio.remap(1.0, 1.25, 0.0, 1.0)
                stretchDriver >> stretched.weight

                # Drive the bump map too
                bumpDriver = squashStretchRatio.remap(0.5, 1.25, 0.32, 0.0)
                bumpDriver >> r.PyNode('fractal2').attr('amplitude')

                # Skinning
                joints = spineCurve.distributeJoints(
                    numJoints, 'y', 'x',
                    aimCurve=aimCurve,
                    closestPoint=True,
                    plug=True
                )

                skin = r.nodes.SkinCluster.create(joints, baseMesh, dropoffRate=2)

                # Cleanup
                r.hide(squashMesh, stretchMesh,
                       spineCurve, aimCurve, startLoc, endLoc)


Example #2: Radial Repulsor
---------------------------

.. tabs::

    .. tab:: Viewport

        .. figure:: repulsor.gif
            :align: center

    .. tab:: Paya

        .. code-block:: python

            from random import uniform
            import paya.runtime as r
            from paya.util import pad

            def createRadialRepulsor(
                    repulseRadius=3.5,
                    swarmRadius=5,
                    numBees=60,
                    beeRadius=0.2
            ):
                repLoc = r.spaceLocator(n='repulsion_centre_LOCT')
                repLoc.addAttr('repulseRadius', min=0, dv=repulseRadius, k=True)
                repulseRadius = repLoc.attr('repulseRadius')
                repCentre = repLoc.attr('worldPosition')

                for i in range(numBees):
                    sphere = r.polySphere(
                        ch=False,
                        radius=beeRadius,
                        n='collider_{}_NRSF'.format(pad(i+1, 3))
                    )[0]

                    initPosition = r.data.Point([
                        uniform(-1, 1),
                        uniform(-1, 1),
                        uniform(-1, 1)
                    ]).normal() * uniform(0, swarmRadius)

                    vector = initPosition - repCentre
                    vector = vector.normal() * vector.length().max(repulseRadius)
                    (repCentre + vector) >> sphere.attr('t')

    .. tab:: PyMEL

        .. code-block:: python

            from random import uniform
            import pymel.core as p

            def createRadialRepulsor(
                    repulseRadius=3.5,
                    swarmRadius=5,
                    numBees=60,
                    beeRadius=0.2
            ):
                repLoc = p.spaceLocator(n='repulsion_centre_LOCT')
                repLoc.addAttr('repulseRadius', min=0, dv=repulseRadius, k=True)
                repulseRadius = repLoc.attr('repulseRadius')
                repCentre = repLoc.attr('worldPosition')

                for i in range(numBees):
                    num = str(i+1)
                    num = '0'*(3-len(num)) + num

                    sphere = r.polySphere(
                        ch=False,
                        radius=beeRadius,
                        n='collider_{}_NRSF'.format(num)
                    )[0]

                    initPosition = p.datatypes.Point([
                        uniform(-1, 1),
                        uniform(-1, 1),
                        uniform(-1, 1)
                    ]).normal() * uniform(0, swarmRadius)

                    pma = p.createNode('plusMinusAverage')
                    pma.attr('operation').set(2)

                    pma.attr('input3D')[0].set(initPosition)
                    repCentre >> pma.attr('input3D')[1]

                    vector = pma.attr('output3D')

                    db = p.createNode('distanceBetween')
                    vector >> db.attr('point2')
                    mag = db.attr('distance')

                    mdv = p.createNode('multiplyDivide')
                    mdv.attr('operation').set(2)

                    vector >> mdv.attr('input1')

                    for child in mdv.attr('input2').getChildren():
                        mag >> child

                    vector = mdv.attr('output')

                    cond = p.createNode('condition')
                    mag >> cond.attr('firstTerm')
                    repulseRadius >> cond.attr('secondTerm')
                    cond.attr('operation').set(2)

                    mag >> cond.attr('colorIfTrueR')
                    repulseRadius >> cond.attr('colorIfFalseR')
                    mag = cond.attr('outColorR')

                    mdv = p.createNode('multiplyDivide')
                    vector >> mdv.attr('input1')

                    for child in mdv.attr('input2').getChildren():
                        mag >> child

                    vector = mdv.attr('output')

                    pma = p.createNode('plusMinusAverage')
                    repCentre >> pma.attr('input3D')[0]
                    vector >> pma.attr('input3D')[1]

                    pma.attr('output3D') >> sphere.attr('t')


.. toctree::
    :hidden:

    What's New <whats_new>
    Getting Started <getting_started>

.. toctree::
    :caption: Rigging
    :hidden:

    Maths <maths_rigging>
    Joint Chains <joint_chains>
    IK Handles <ik>
    deformers
    geometry
    Controls <controls>
    User Attributes <user_attrs>
    Node Names <naming_nodes>

.. toctree::
    :caption: Customisation
    :hidden:

    Adding Your Own Methods <adding_oo_functionality>
    Package Configuration <package_config>
    Sugar and Style <sugar_and_style>

.. toctree::
    :caption: Appendices
    :hidden:

    Types <types_index>
    Modules <paya>
    implementation
    glossary
    licence
    author