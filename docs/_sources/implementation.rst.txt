**************
Implementation
**************

There are two aspects to the **paya** patching mechanism.

1. Class Construction
---------------------

Custom **paya** classes are built in the following way:

    1.  Where available, content is taken from user (or bundled)
        :ref:`template classes <template modules>`.

    2.  The custom classes are then built using special metaclasses that
        manage inheritance via an overriden ``mro()``.

Custom node, component and data types always shadow a PyMEL counterpart in the
method resolution order. However, when it comes to **plug** (attribute) types,
PyMEL only provides one class: :py:class:`pymel.core.general.Attribute`. For
this reason, custom plug types are largely abstract, and constructed according
to an inheritance tree defined inside ``paya/plugtree.json``.

2. Instance Interception
------------------------

``__new__()`` constructors on PyMEL classes inside :py:mod:`pymel.core.general`, :py:mod:`pymel.core.nodetypes` and
:py:mod:`pymel.core.datatypes` are then dynamically replaced with wrappers that capture new PyNode instances and
change their ``__class__`` assignment.

Lookups are cached throughout.

Advantages
----------

-   **Speed**: Instantiating PyNodes is notoriously slow, and therefore
    avoided entirely.

-   **Easy coupling / decoupling**: Unpatching PyMEL is merely a case of
    removing the ``__new__()`` wrappers.

-   **Compatibility**: PyMEL treats custom objects as its own.

-   **Simpler Customisation**: Inheritance is managed entirely during the
    rebuilding stage; users do not need to track it for class declarations.

For more information, take a look inside :py:mod:`paya.pools` and :py:mod:`paya.patch`.