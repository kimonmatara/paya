##########
What's New
##########

*************
Version 0.4.2
*************

General Changes
===============

*   :meth:`paya.plugtypes.matrix.Matrix.decomposeAndApply` and :meth:`paya.datatypes.matrix.Matrix.decomposeAndApply`
    escape into simpler / faster implementations when no ``rotateAxis``, ``jointOrient``, ``inverseScale`` or pivot
    compensations are requested or required

*************
Version 0.4.1
*************

General Changes
===============

*   Smarter defaults handling on :meth:`paya.nodetypes.ikHandle.IkHandle.create`
*   Added :doc:`IK Handles <ik>` section to documentation
*   Removed :meth:`~paya.lib.skel.Chain` subclasses to simplify

Bugs Fixed
==========

*   :meth:`~paya.lib.skel.Chain.createFromCurve` fails with error about missing 'override' object
*   Missing :meth:`~paya.lib.skel.Chain.createIkHandle`
*   :meth:`~paya.lib.skel.Chain.orient` does not return ``self``

***********
Version 0.4
***********

General Changes
===============

*   Naming arguments on :meth:`~paya.nodetypes.dependNode.DependNode.createNode` and elsewhere have been simplified,
    with many moved into :mod:`paya.config` instead.

Additions to Modules
====================

*   Added :mod:`paya.config`
*   Added :mod:`paya.lib.skel`, including :class:`~paya.lib.skel.Chain` and subclasses

Additions to Data Types
=======================

*   On :class:`~paya.datatypes.vector.Vector`:
    :meth:`~paya.datatypes.vector.Vector.rotateByAxisAngle`
    :meth:`~paya.datatypes.vector.Vector.asScaleMatrix`

*   On :class:`~paya.datatypes.matrix.Matrix`:
    :meth:`~paya.datatypes.matrix.Matrix.decomposeAndApply`

Additions / Changes to Plug Types
=================================

*   On :class:`~paya.plugtypes.attribute.Attribute`:
    :meth:`~paya.plugtypes.attribute.Attribute.release`

*   On :class:`~paya.plugtypes.compound.Compound`:
    :meth:`~paya.plugtypes.compound.Compound.release`
    :meth:`~paya.plugtypes.compound.Compound.splitInputs`

*   On :class:`~paya.plugtypes.vector.Vector`:
    :meth:`~paya.plugtypes.vector.Vector.rotateByAxisAngle`

*   On :class:`~paya.plugtypes.angle.Angle`:
    :meth:`~paya.plugtypes.angle.Angle.set`

*   On :class:`~paya.plugtypes.eulerRotation.EulerRotation`:
    :meth:`~paya.plugtypes.eulerRotation.EulerRotation.set` now auto-converts units when the value is an
    :class:`~paya.datatypes.eulerRotation.EulerRotation`; added
    :meth:`~paya.plugtypes.eulerRotation.EulerRotation.asRotateMatrix`

*   On :class:`~paya.plugtypes.matrix.Matrix`:
    :meth:`~paya.plugtypes.matrix.Matrix.decomposeAndApply`

Additions to Node Types
=======================

*   On :class:`~paya.nodetypes.transform.Transform`:
    :meth:`~paya.nodetypes.transform.Transform.releaseSRT`
    :meth:`~paya.nodetypes.transform.Transform.getWorldMatrix`
    :meth:`~paya.nodetypes.transform.Transform.getWorldPosition`
    :meth:`~paya.nodetypes.transform.Transform.getRotateAxisMatrix`

*   On :class:`~paya.nodetypes.joint.Joint`:
    :meth:`~paya.nodetypes.joint.Joint.skinClusters`
    :meth:`~paya.nodetypes.joint.Joint.ikHandles`
    :meth:`~paya.nodetypes.joint.Joint.chainFromHere`
    :meth:`~paya.nodetypes.joint.Joint.getJointOrientMatrix`

*   On :class:`~paya.nodetypes.ikHandle.IkHandle`:
    :meth:`~paya.nodetypes.ikHandle.IkHandle.create`
    :meth:`~paya.nodetypes.ikHandle.IkHandle.getEndJoint`
    :meth:`~paya.nodetypes.ikHandle.IkHandle.getJointList` (overload for ``includeTip``)
    :meth:`~paya.nodetypes.ikHandle.IkHandle.chain`
    :meth:`~paya.nodetypes.ikHandle.IkHandle.setTwistVectors`
    :meth:`~paya.nodetypes.ikHandle.IkHandle.setPolePoint`

*   On :class:`~paya.nodetypes.nurbsCurve.NurbsCurve`:
    :meth:`~paya.nodetypes.nurbsCurve.NurbsCurve.takeClosestPoint`
    :meth:`~paya.nodetypes.nurbsCurve.NurbsCurve.takePointAtParam`
    :meth:`~paya.nodetypes.nurbsCurve.NurbsCurve.takeParamAtFraction`
    :meth:`~paya.nodetypes.nurbsCurve.NurbsCurve.takePointAtFraction`
    :meth:`~paya.nodetypes.nurbsCurve.NurbsCurve.distributePoints`

Additions to General Classes
============================

*   On :class:`~paya.lib.skel.Chain`:
    :meth:`~paya.lib.skel.Chain.getFromStartEnd`
    :meth:`~paya.lib.skel.Chain.getFromRoot`
    :meth:`~paya.lib.skel.Chain.createFromMatrices`
    :meth:`~paya.lib.skel.Chain.createFromPoints`
    :meth:`~paya.lib.skel.Chain.createFromCurve`
    :meth:`~paya.lib.skel.Chain.createFromCurve`
    :meth:`~paya.lib.skel.Chain.orient`
    :meth:`~paya.lib.skel.Chain.bones`
    :meth:`~paya.lib.skel.Chain.vectors`
    :meth:`~paya.lib.skel.Chain.points`
    :meth:`~paya.lib.skel.Chain.contiguous`
    :meth:`~paya.lib.skel.Chain.roots`
    :meth:`~paya.lib.skel.Chain.length`
    :meth:`~paya.lib.skel.Chain.insertJointsAtRatios`
    :meth:`~paya.lib.skel.Chain.skinClusters`
    :meth:`~paya.lib.skel.Chain.ikHandles`
    :meth:`~paya.lib.skel.Chain.downAxis`
    :meth:`~paya.lib.skel.Chain.duplicate`
    :meth:`~paya.lib.skel.Chain.rename`
    :meth:`~paya.lib.skel.Chain.compose`
    :meth:`~paya.lib.skel.Chain.explode`
    :meth:`~paya.lib.skel.Chain.appendChain`
    :meth:`~paya.lib.skel.Chain.getPolePoint`
    :meth:`~paya.lib.skel.Chain.autoPreferredAngle`
    :meth:`~paya.lib.skel.Chain.reset`
    :meth:`~paya.lib.skel.Chain.createIkHandle`
    :meth:`~paya.lib.skel.Chain.createIkHandles`

*   On :class:`~paya.lib.skel.Bone`:
    :meth:`~paya.lib.skel.Bone.insertJoints`

----

***********
Version 0.3
***********

General Changes
===============

The abstract plug tree has been reworked to make names more intuitive and to better support angles
and euler rotations.

Bugs Fixed
==========

*   Contextual naming misapplied when
    :meth:`~paya.nodetypes.dependNode.DependNode.createNode` is used for shapes
*   Some :term:`universal` operators don't work properly when called on
    :class:`paya.datatypes.point.Point` rather than :class:`paya.datatypes.vector.Vector`

Additions to Modules
====================

*   On :mod:`paya.lib.mathops`: :func:`~paya.lib.mathops.createMatrix` :func:`~paya.lib.mathops.asValue`

Additions to Node Types
=======================

*   On :class:`~paya.nodetypes.fourByFourMatrix.FourByFourMatrix`:
    :meth:`~paya.nodetypes.fourByFourMatrix.FourByFourMatrix.getAxis`
    :meth:`~paya.nodetypes.fourByFourMatrix.FourByFourMatrix.getX`
    :meth:`~paya.nodetypes.fourByFourMatrix.FourByFourMatrix.getY`
    :meth:`~paya.nodetypes.fourByFourMatrix.FourByFourMatrix.getZ`
    :meth:`~paya.nodetypes.fourByFourMatrix.FourByFourMatrix.getTranslate`
    :attr:`translate/t`
    :attr:`x` :attr:`y` :attr:`z`

*   On :class:`~paya.nodetypes.shape.Shape`: :meth:`~paya.nodetypes.shape.Shape.createNode`

Additions to Plug Types
=======================

*   On :class:`~paya.plugtypes.attribute.Attribute`:
    :meth:`~paya.plugtypes.attribute.Attribute.plugType`

*   On :class:`~paya.plugtypes.angle.Angle`:
    :meth:`~paya.plugtypes.angle.Angle.get`

*   On :class:`~paya.plugtypes.compound.Compound`:
    :meth:`~paya.plugtypes.compound.Compound.__iter__`

*   On :class:`~paya.plugtypes.enum.Enum`:
    :meth:`~paya.plugtypes.enum.Enum.put`

*   On :class:`~paya.plugtypes.eulerRotation.EulerRotation`:
    :meth:`~paya.plugtypes.eulerRotation.EulerRotation.get`
    :meth:`~paya.plugtypes.eulerRotation.EulerRotation.isRotateChannel`
    :meth:`~paya.plugtypes.eulerRotation.EulerRotation.asQuaternion`
    :meth:`~paya.plugtypes.eulerRotation.EulerRotation.asRotateMatrix`

*   On :class:`~paya.plugtypes.math1D.Math1D`:
    :meth:`~paya.plugtypes.math1D.Math1D.sqrt`
    :meth:`~paya.plugtypes.math1D.Math1D.__neg__`
    :meth:`~paya.plugtypes.math1D.Math1D.abs`
    :meth:`~paya.plugtypes.math1D.Math1D.cycle`
    :meth:`~paya.plugtypes.math1D.Math1D.remap`
    :meth:`~paya.plugtypes.math1D.Math1D.clamp`
    :meth:`~paya.plugtypes.math1D.Math1D.minClamp`
    :meth:`~paya.plugtypes.math1D.Math1D.min`
    :meth:`~paya.plugtypes.math1D.Math1D.eq`
    :meth:`~paya.plugtypes.math1D.Math1D.ne`
    :meth:`~paya.plugtypes.math1D.Math1D.gt`
    :meth:`~paya.plugtypes.math1D.Math1D.ge`
    :meth:`~paya.plugtypes.math1D.Math1D.lt`
    :meth:`~paya.plugtypes.math1D.Math1D.le`
    :meth:`~paya.plugtypes.math1D.Math1D.choose`
    :meth:`~paya.plugtypes.math1D.Math1D.blend`
    :meth:`~paya.plugtypes.math1D.Math1D.unaryExpr`
    :meth:`~paya.plugtypes.math1D.Math1D.degrees`
    :meth:`~paya.plugtypes.math1D.Math1D.radians`
    :meth:`~paya.plugtypes.math1D.Math1D.cos`
    :meth:`~paya.plugtypes.math1D.Math1D.sin`
    :meth:`~paya.plugtypes.math1D.Math1D.tan`
    :meth:`~paya.plugtypes.math1D.Math1D.acos`
    :meth:`~paya.plugtypes.math1D.Math1D.asin`
    :meth:`~paya.plugtypes.math1D.Math1D.atan`
    :meth:`~paya.plugtypes.math1D.Math1D.atTime`

*   On :class:`~paya.plugtypes.math3D.Math3D`:
    :meth:`~paya.plugtypes.math3D.Math3D.get`
    :meth:`~paya.plugtypes.math3D.Math3D.blend`

*   On :class:`~paya.plugtypes.matrix.Matrix`:
    :meth:`~paya.plugtypes.matrix.Matrix.createLocator`
    :meth:`~paya.plugtypes.matrix.Matrix.pick`
    :meth:`~paya.plugtypes.matrix.Matrix.inverse`
    :meth:`~paya.plugtypes.matrix.Matrix.asOffset`
    :meth:`~paya.plugtypes.matrix.Matrix.getAxis`
    :meth:`~paya.plugtypes.matrix.Matrix.getX`
    :meth:`~paya.plugtypes.matrix.Matrix.getY`
    :meth:`~paya.plugtypes.matrix.Matrix.getZ`
    :meth:`~paya.plugtypes.matrix.Matrix.getTranslate`
    :attr:`x` :attr:`y` :attr:`z` :attr:`translate/t`
    :meth:`~paya.plugtypes.matrix.Matrix.transpose`
    :meth:`~paya.plugtypes.matrix.Matrix.decompose`
    :meth:`~paya.plugtypes.matrix.Matrix.hold`
    :meth:`~paya.plugtypes.matrix.Matrix.asEulerRotation`
    :meth:`~paya.plugtypes.matrix.Matrix.asQuaternion`

*   On :class:`~paya.plugtypes.quaternion.Quaternion`:
    :meth:`~paya.plugtypes.quaternion.Quaternion.inverse`
    :meth:`~paya.plugtypes.quaternion.Quaternion.normal`
    :meth:`~paya.plugtypes.quaternion.Quaternion.conjugate`
    :meth:`~paya.plugtypes.quaternion.Quaternion.blend`
    :meth:`~paya.plugtypes.quaternion.Quaternion.asEulerRotation`
    :meth:`~paya.plugtypes.quaternion.Quaternion.asAxisAngle`
    :meth:`~paya.plugtypes.quaternion.Quaternion.asRotateMatrix`

*   On :class:`~paya.plugtypes.string.String`:
    :meth:`~paya.plugtypes.string.String.put`

*   On :class:`~paya.plugtypes.vector.Vector`:
    :meth:`~paya.plugtypes.vector.Vector.dot`
    :meth:`~paya.plugtypes.vector.Vector.length`
    :meth:`~paya.plugtypes.vector.Vector.normal`
    :meth:`~paya.plugtypes.vector.Vector.cross`
    :meth:`~paya.plugtypes.vector.Vector.angle`
    :meth:`~paya.plugtypes.vector.Vector.asTranslateMatrix`
    :meth:`~paya.plugtypes.vector.Vector.asScaleMatrix`
    :meth:`~paya.plugtypes.vector.Vector.asEulerRotation`

Additions to Data Types
=======================


*   On :class:`~paya.datatypes.eulerRotation.EulerRotation`:
    :meth:`~paya.datatypes.eulerRotation.EulerRotation.__add__`
    :meth:`~paya.datatypes.eulerRotation.EulerRotation.__radd__`
    :meth:`~paya.datatypes.eulerRotation.EulerRotation.__sub__`
    :meth:`~paya.datatypes.eulerRotation.EulerRotation.__mul__`
    :meth:`~paya.datatypes.eulerRotation.EulerRotation.__rmul__`
    :meth:`~paya.datatypes.eulerRotation.EulerRotation.__truediv__`
    :meth:`~paya.datatypes.eulerRotation.EulerRotation.__rtruediv__`
    :meth:`~paya.datatypes.eulerRotation.EulerRotation.__pow__`
    :meth:`~paya.datatypes.eulerRotation.EulerRotation.__rpow__`

*   On :class:`~paya.datatypes.matrix.Matrix`:
    :meth:`~paya.datatypes.matrix.Matrix.createLocator`
    :meth:`~paya.datatypes.matrix.Matrix.decompose`
    :meth:`~paya.datatypes.matrix.Matrix.pick`
    :meth:`~paya.datatypes.matrix.Matrix.asOffset`
    :meth:`~paya.datatypes.matrix.Matrix.hold`
    :meth:`~paya.datatypes.matrix.Matrix.getAxis`
    :meth:`~paya.datatypes.matrix.Matrix.setAxis`
    :meth:`~paya.datatypes.matrix.Matrix.getX`
    :meth:`~paya.datatypes.matrix.Matrix.setX`
    :meth:`~paya.datatypes.matrix.Matrix.getY`
    :meth:`~paya.datatypes.matrix.Matrix.setY`
    :meth:`~paya.datatypes.matrix.Matrix.getZ`
    :meth:`~paya.datatypes.matrix.Matrix.setZ`
    :meth:`~paya.datatypes.matrix.Matrix.getTranslate`
    :meth:`~paya.datatypes.matrix.Matrix.setTranslate`
    :attr:`~paya.datatypes.matrix.Matrix.x`
    :attr:`~paya.datatypes.matrix.Matrix.y`
    :attr:`~paya.datatypes.matrix.Matrix.z`
    :attr:`~paya.datatypes.matrix.Matrix.translate` / :attr:`~paya.datatypes.matrix.Matrix.t`

*   On :class:`~paya.datatypes.point.Point`:
    :meth:`~paya.datatypes.point.Point.__add__`
    :meth:`~paya.datatypes.point.Point.__radd__`
    :meth:`~paya.datatypes.point.Point.__sub__`
    :meth:`~paya.datatypes.point.Point.__rsub__`
    :meth:`~paya.datatypes.point.Point.__mul__`
    :meth:`~paya.datatypes.point.Point.__rmul__`
    :meth:`~paya.datatypes.point.Point.__truediv__`
    :meth:`~paya.datatypes.point.Point.__rtruediv__`
    :meth:`~paya.datatypes.point.Point.__pow__`
    :meth:`~paya.datatypes.point.Point.__rpow__`

*   On :class:`~paya.datatypes.vector.Vector`:
    :meth:`~paya.datatypes.vector.Vector.blend`
    :meth:`~paya.datatypes.vector.Vector.dot`
    :meth:`~paya.datatypes.vector.Vector.cross`
    :meth:`~paya.datatypes.vector.Vector.angle`

-----

***********
Version 0.2
***********

Additions
=========

*   A wide range of maths operators, spread across :doc:`paya/plugtypes` and :doc:`paya/datatypes`, with support for
    bidirectional mixing of values and plugs
*   Added  :meth:`~paya.plugtypes.attributeMath16D.AttributeMath16D.pick` and
    :meth:`~paya.plugtypes.attributeMath16D.AttributeMath16D.asOffset`
    to :class:`~paya.plugtypes.attributeMath16D.AttributeMath16D`
*   Added  :meth:`~paya.datatypes.matrix.Matrix.pick` and :meth:`~paya.datatypes.matrix.Matrix.asOffset`
    to :class:`~paya.datatypes.matrix.Matrix`
*   :meth:`~paya.plugtypes.attribute.Attribute.get` returns :ref:`more useful types <More Useful Query Types>`
*   The double-chevron operator ``>>`` :ref:`now supports value-setting <Extended Chevrons>`
*   :doc:`Contextual name management <naming_nodes>` with :class:`paya.lib.names.Name` and pipeline suffixes
*   :ref:`Dodge unit conversion nodes <Preventing Unit Conversions>` with :class:`paya.lib.mathops.NativeUnits` and :func:`paya.lib.mathops.nativeUnits`

-----

***********
Version 0.1
***********

Additions
=========

*   Patching engine
*   :mod:`paya.runtime` interface