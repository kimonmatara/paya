Tutorial #3: Custom Operators
=============================

Background
----------

PyMEL only offers one class for plugs, namely
:py:class:`pymel.core.general.Attribute`. **Paya** expands this with subtypes
built off of an abstract inheritance tree defined inside ``paya/plugtree.json``.

Compare the inheritance of an unpatched PyMEL attribute instance:

.. code-block:: python

    >>> import pymel.core as pm
    >>> plug = pm.PyNode('persp').attr('translate')
    >>> cls = type(plug)
    >>> print(cls.__mro__)
    (<class 'pymel.core.general.Attribute'>, <class 'pymel.core.general.PyNode'>, <class 'pymel.util.utilitytypes.proxyClass.<locals>.Proxy'>, <class 'object'>)

With the **paya** version:

.. code-block:: python

    >>> import paya.runtime as r
    PyMEL patched successfully.

    >>> plug = r.PyNode('persp').attr('translate')
    >>> cls = type(plug)
    >>> print(cls.__mro__)
    (<class 'paya.plugtypes.attribute3Double.Attribute3Double'>, <class 'paya.plugtypes.attributeMath3D.AttributeMath3D'>, <class 'paya.plugtypes.attributeMath.AttributeMath'>, <class 'paya.plugtypes.attribute.Attribute'>, <class 'pymel.core.general.Attribute'>, <class 'pymel.core.general.PyNode'>, <class 'pymel.util.utilitytypes.proxyClass.<locals>.Proxy'>, <class 'object'>)

This expanded inheritance offers several more 'hooks' for customisation.

Example: Scalar Addition
------------------------

Suppose you want to add the outputs of two scalar attributes; in
'vanilla' PyMEL, this would look like this:

..  code-block:: python

    plug1 = p.PyNode('locator1').attr('tx')
    plug2 = p.PyNode('locator2').attr('tx')

    adl = p.createNode('addDoubleLinear')
    plug1 >> adl.attr('input1')
    plug2 >> adl.attr('input2')

    output = adl.attr('output')

A more intuitive approach would be to use simple maths notation, like this:

.. code-block:: python

    output = plug1 + plug2

This is very easy to implement in **paya**. All you need to do is:

1.  Start a template class inside ``paya/plugtypes/attributeMath1D.py``.

2.  Implement the Python magic ('dunder') method ``__add__``, like this:

    .. code-block:: python

        import paya.runtime as r

        class AttributeMath1D:

            def __add__(self, other):
                adl = r.createNode('addDoubleLinear')
                self >> adl.attr('input1')
                other >> adl.attr('input2')

                return adl.attr('output')

3.  Back in Maya, reload the class pools, re-instantiate and test:

    .. code-block:: python

        >>> import paya.runtime as r
        >>> r.rehash()

        >>> plug1 = r.PyNode('locator1').attr('tx')
        >>> plug2 = r.PyNode('locator2').attr('tx')

        >>> print(plug1+plug2)
        addDoubleLinear1.output

.. note::

    Targeting the more general :py:class:`~paya.plugtypes.AttributeMath1D` instead of
    :py:class:`~paya.plugtypes.AttributeDoubleLinear` ensures that the operator
    is implemented across every scalar subtype, including
    :py:class:`~paya.plugtypes.AttributeDoubleAngle`,
    :py:class:`~paya.plugtypes.AttributeEnum` and so on.