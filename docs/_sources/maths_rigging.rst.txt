*************
Maths Rigging
*************

============
Introduction
============

Paya allows you to work with values and plugs interchangeably in your rigging scripts, without having to wire-up nodes
explicitly. To achieve this, it copies methods from PyMEL's data classes onto attributes and, conversely, implements
common node-based workflows as methods on both.

.. note::

    `Polymorphism <https://en.wikipedia.org/wiki/Polymorphism_(computer_science)>`_ for maths rigging in Paya is an
    ongoing project. Stay tuned for more methods in upcoming Paya releases.

Before delving further, take note of a few enhancements you may encounter later:

.. _Extended Chevrons:

*   In Paya, the double-chevron operator ``>>`` can be used to **set values** as well as connect attributes:

    .. code-block:: python

        3.0 >> loc.tx

        # Equivalent to:
        loc.tx.set(3.0)

.. _More Useful Query Types:

*   To set you up for mixed-mode operations, :meth:`~paya.plugtypes.attribute.Attribute.get` behaves somewhat
    differently:

    -   When called on the ``translate`` channel of a transform, it returns a
        :class:`~pymel.core.datatypes.point.Point`

    -   When called on the ``rotate`` channel of a transform, it returns an
        :class:`~pymel.core.datatypes.eulerRotation.EulerRotation`

    -   When called on scalar compounds with four children, it returns a
        :class:`~pymel.core.datatypes.Quaternion`

=========
Operators
=========

As of version 0.2, all of the following statements are valid, and will generate appropriate node networks implicitly:

.. code-block:: python

    loc.translate + 3 # creates plusMinusAverage
    3 + loc.translate # creates plusMinusAverage
    p.datatypes.Vector([1, 2, 3]) * 'locator1.worldMatrix' # creates pointMatrixMult with vectorMultiply on

However, the following would error, or yield unexpected results:

.. code-block:: python

    'locator1.translate' + 3
    [0.3, 2.0, 1.0] * 'locator1.worldMatrix'
    3 * [0.3, 2.0, 1.0]
    'locator1.worldMatrix' * 'locator2.worldMatrix'

This is because when both operands are simple Python types, it's impossible to determine the intended Paya (or PyMEL)
method.

Available operators are documented under :doc:`paya/plugtypes` and :doc:`paya/datatypes`.

===========================
Point-Matrix Multiplication
===========================

Point-Matrix Multiplication
---------------------------

PyMEL uses the ``*`` operator both for vector-matrix and point-matrix multiplication. The latter is triggered when
the left operand is a :class:`~pymel.core.datatypes.Point` rather than a :class:`~pymel.core.datatypes.Vector` instance.
Paya extends this behaviour to support matrix attributes:

.. code-block:: python

    point = r.data.Point([0,2,3])
    point * loc.worldMatrix # point * 'locator1.worldMatrix' also works

The above example would configure a ``pointMatrixMult`` node with vectorMultiply set to False.

Additionally, because in Paya :meth:`~paya.plugtypes.Attribute.get` called on ``translate`` channels always returns a
:class:`~pymel.core.datatypes.Point` instance, the following will produce point-matrix multiplication by default:

.. code-block:: python

    loc1.translate.get() * loc2.worldMatrix

    # The following also works
    loc1.translate.get() * 'locator2.worldMatrix'


Paya also supports triple scalar attributes (i.e., ``double3``) as the left operand. However, since Maya doesn't
distinguish between point and vector attributes, ``*`` always treats them as vectors. In such cases you can use a
new ``^`` operator for point-matrix multiplication:

.. code-block:: python

    (loc1.t + loc2.t) ^ loc3.wm # pointMatrixMult.vectorMultiply set to False
    (loc1.t + loc2.t) * loc3.wm # pointMatrixMult.vectorMultiply set to True
    pma.output3D.get() ^ loc3.wm.get() # available on values too

=====================
Working with Matrices
=====================

Maintain Offset
---------------

When developing matrix-based constraints with Paya, you can emulate the ``maintainOffset/mo`` constraint option in
Maya's constraints like this:

.. code-block:: python

    master = r.PyNode('locator1')
    slave = r.PyNode('locator2')

    masterMatrix = master.worldMatrix
    masterMatrix = masterMatrix * masterMatrix.get().inverse() # to identity once
    slavePose = slave.getMatrix(worldSpace=True)
    masterMatrix = slavePose * masterMatrix

    slave.inheritsTransform.set(False)
    masterMatrix >> slave.offsetParentMatrix

Because this is such a common recipe, Paya provides a convenient macro for it,
:meth:`~paya.plugtypes.attributeMath16D.AttributeMath16D.asOffset`:

.. code-block:: python

    (slavePose * master.worldMatrix.asOffset()) >> slave.offsetParentMatrix

For polymorphic parity, the method has also been made available on :class:`~paya.datatypes.matrix.Matrix`, where it will
merely return an identity matrix.

Filtering
---------

Matrix filtering via ``pickMatrix`` nodes can be concisely performed using the
:meth:`~paya.plugtypes.attributeMath16D.AttributeMath16D.pick` method on matrix attributes, also available via the
shorthand ``pk``. The method has also been replicated statically on :class:`~paya.datatypes.matrix.Matrix` objects:

.. code-block:: python

    master.worldMatrix.pick(rotate=True) >> slave.offsetParentMatrix # dynamic
    master.worldMatrix.get().pick(rotate=True) >> slave.offsetParentMatrix # static

Both versions also accept a ``default`` argument, allowing you to take omitted fields from a fallback matrix plug or
value. The returned matrix is recombined according to Maya's transformation model, i.e.
``scale * shear * rotate * translate``. This allows you to create 'partial' matrix constraints, akin to
connecting specific outputs of a ``decomposeMatrix``:

.. code-block:: python

    fallbackMatrix = r.PyNode('root_XFRM').worldMatrix
    masterMatrix = r.PyNode('locator1').worldMatrix.pk(rotate=True, default=fallbackMatrix)
    masterMatrix >> r.PyNode('locator2').offsetParentMatrix

In the above example, 'locator2' would take rotation from 'locator1', and translate, scale and shear from 'root_XFRM'.

===========================
Preventing Unit Conversions
===========================

Paya doesn't attempt to account for ``unitConversion`` nodes. Instead, it's written under the assumption that Maya is
configured for native units (namely, centimetres and radians) so that these nodes won't be generated at all, and gives
you a couple of tools to enforce this for blocks you specify.

The first is the :class:`~paya.lib.mathops.NativeUnits` context manager:

.. code-block:: python

    from paya.lib.mathops import NativeUnits # capitalised

    with NativeUnits():
        loc1.rx * loc2.ty

The second is :func:`~paya.lib.mathops.nativeUnits`, a decorator for methods and functions:

.. code-block:: python

    from paya.lib.mathops import nativeUnits # uncapitalised

    @nativeUnits
    def angleMath(loc1, loc2):
        return loc1.rx * loc2.ty

In both cases Maya unit preferences are restored on block exit.

.. note::
    This approach greatly simplifies working with arithmetic operations, but means you will be working with radians rather
    than degrees. If you find degrees more intuitive to inspect, you can use :func:`pymel.util.radians` and
    :func:`pymel.util.degrees` for conversions.