Tutorial #1: Custom Methods
===========================

Suppose you want to create an object-oriented version of
:func:`~pymel.core.modeling.pointPosition()` so that you can do this:

.. code-block:: python

    mesh.vtx[6].getWorldPosition()


Instead of this:

.. code-block:: python

    p.pointPosition(mesh.vtx[6])


1. Identifying the Class to Customise
-------------------------------------

To find the class to target, you could start by inspecting, say, a vertex
instance:

.. code-block:: python

    >>> vertex = r.PyNode('pCube1').vtx[6]
    >>> cls = type(vertex) # vertex.__class__ also works
    >>> print(cls)
    <class 'paya.comptypes.meshVertex.MeshVertex'>

This might suggest that the class you need to work on is
:py:class:`~paya.comptypes.MeshVertex`. However, you probably want to add ``getWorldPosition()``
to every component type supported by :func:`~pymel.core.modeling.pointPosition()`.

Since **paya** supports true inheritance, it would be better to target a more general class, one that
:py:class:`~paya.comptypes.MeshVertex` as well as other types like
:py:class:`~paya.comptypes.NurbsCurveCV` all inherit from.

You can inspect the inheritance stack of :py:class:`~paya.comptypes.MeshVertex`
via its ``__mro__`` class attribute, like this:

.. code-block:: python

    >>> print(cls).__mro__
    (<class 'paya.comptypes.meshVertex.MeshVertex'>, <class 'pymel.core.general.MeshVertex'>, <class 'paya.comptypes.mItComponent1D.MItComponent1D'>, <class 'pymel.core.general.MItComponent1D'>, <class 'paya.comptypes.mItComponent.MItComponent'>, <class 'pymel.core.general.MItComponent'>, <class 'paya.comptypes.component1D.Component1D'>, <class 'pymel.core.general.Component1D'>, <class 'paya.comptypes.discreteComponent.DiscreteComponent'>, <class 'pymel.core.general.DiscreteComponent'>, <class 'paya.comptypes.dimensionedComponent.DimensionedComponent'>, <class 'pymel.core.general.DimensionedComponent'>, <class 'paya.comptypes.component.Component'>, <class 'pymel.core.general.Component'>, <class 'pymel.core.general.PyNode'>, <class 'pymel.util.utilitytypes.proxyClass.<locals>.Proxy'>, <class 'object'>)

Scanning through the members, :py:class:`~paya.comptypes.DiscreteComponent`
looks like a better candidate for customisation: *discrete* suggests that
point-like components will be included, but continuous components like NURBS
isoparms will be excluded.

2. Authoring the Class
----------------------

Custom **paya** classes are defined in 'template' modules. Depending on type,
these are stored inside ``paya/nodetypes``, ``paya/comptypes``, ``paya/plugtypes``
or ``paya/datatypes``. Each module name is always the uncapitalised name of the
class it defines.

Since we want to start a custom class for
:py:class:`~paya.comptypes.DiscreteComponent`, we need to create the following
file: ``paya/comptypes/discreteComponent.py``.

Authoring the class is very easy. In this case, the module content amounts to this:

.. code-block:: python

    import paya.runtime as r

    class DiscreteComponent:

        def getWorldPosition(self):
            return r.pointPosition(self, world=True)

.. note::

    Those familiar with object-oriented programming in Python might have
    expected to see this instead:

    .. code-block:: python

        import pymel.core.general

        class DiscreteComponent(pymel.core.general.DiscreteComponent):
            [...]

    This is not necessary, because template classes are rebuilt by **paya**
    to enforce correct inheritance. While this simplifies class authoring,
    it has a couple of drawbacks:

    -   Template classes should never be imported directly (even by other
        template classes); instead, they must always be accessed via the
        :py:mod:`paya.runtime` interfaces.

    -   If you want to call a superclass method, you can't use :obj:`super`;
        instead, you must correctly identify and source the parent class for
        the explicit form:

        .. code-block:: python

            from pymel.core.general import DiscreteComponent

            class MeshVertex:
                def getWorldPosition(self):
                    return DiscreteComponent.getWorldPosition(self)

3. Reloading and Using
----------------------

Your new ``getWorldPosition()`` method won't be picked up until you clear the
class pool caches. You can do this by calling
:py:meth:`~paya.runtime.Runtime.rehash`:

.. code-block:: python

    >>> r.rehash()
    Purged class pool paya.nodes.
    Purged class pool paya.plugs.
    Purged class pool paya.comps.
    Purged class pool paya.data.

That's it! Your new class will now be reloaded the next time you create a
component instance, and the ``getWorldPosition()`` method will be ready to use:

.. code-block:: python

    >>> vertex = r.PyNode('pCube1').vtx[6]
    >>> print(vertex.getWorldPosition())
    [10,10,10]

    # Confirm it works on other discrete components too:

    >>> cv = r.PyNode('curve1').cv[0]
    >>> print(cv.getWorldPosition())
    [0.5,0.0,0.0]