**********************
Importing and Patching
**********************

To get started with **paya**, run the following in the Script Editor:

.. code-block:: python

    >>> import paya.runtime
    PyMEL has been patched successfully.

At this point, PyMEL has been patched to return custom Paya classes
instead of its own. To confirm this, run the following and note the class returned by :class:`type`:

.. code-block:: python

    >>> import pymel.core as pm
    >>> cam = pm.PyNode('persp')
    >>> print(type(cam))
    <class 'paya.nodetypes.transform.Transform'>

Now remove the patch, restoring PyMEL to its 'factory state', like this:

.. code-block:: python

    >>> paya.runtime.stop()
    PyMEL has been unpatched successfully.

    >>> cam = pm.PyNode('persp')
    >>> print(type(cam))
    <class 'pymel.core.nodetypes.Transform'>

Notice that :class:`type` now returns the PyMEL base class, :class:`pymel.core.nodetypes.Transform`, instead.

If you wish to re-apply the patch, **import** won't work a second time.
Instead, you must call :py:meth:`~paya.runtime.Runtime.start`:

.. code-block:: python

    >>> paya.runtime.start()
    PyMEL has been patched successfully.

.. note::

    It's important to remember that, once patched, PyMEL will continue to return Paya classes until
    :meth:`~paya.runtime.Runtime.stop` is called. This is not an issue with standard Paya distributions,
    because they do not interfere with standard PyMEL functionality; however, the more customisations
    you add, the more the potential to break external studio's pipeline scripts increases. See
    :ref:`Bracketing` to learn how to customise Paya safely.