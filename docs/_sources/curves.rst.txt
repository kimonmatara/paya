*********************
NURBS & Bezier Curves
*********************

Paya implements too many editing and sampling methods on NURBS and Bezier curves to enumerate in detail here. Instead,
some important workflows will be summarised. For a full reference, see the shape, attribute and component classes:

.. list-table::
    :widths: 30 70

    *   - **Shape**
        - :class:`~paya.runtime.nodes.NurbsCurve` :class:`~paya.runtime.nodes.BezierCurve`

    *   - **Plug**
        - :class:`~paya.runtime.plugs.NurbsCurve` :class:`~paya.runtime.plugs.BezierCurve`

    *   - **Component**
        - :class:`~paya.runtime.comps.NurbsCurveParameter` :class:`~paya.runtime.comps.NurbsCurveCV`

===========
Constructor
===========

The standard :meth:`~paya.runtime.nodes.NurbsCurve.create` constructor on :class:`~paya.runtime.nodes.NurbsCurve`
accepts point plugs as well as values. This makes it easy to create live curves without clusters:

.. tabs::

    .. tab:: Viewport

        .. figure:: live_curve_construction.gif
            :align: center

    .. tab:: Paya

        .. code-block:: python

            locs = r.ls(type='locator')
            points = [loc.attr('worldPosition') for loc in locs]

            r.nodes.NurbsCurve.create(points, degree=3)

The :meth:`~paya.runtime.nodes.BezierCurve.create` constructor on :class:`~paya.runtime.nodes.BezierCurve` behaves
similarly, but will only accept a usable number of CVs. Specifically, there must be enough CVs for the outer anchors to
take two each, and for any inner anchors to receive three each.

.. _curve_framing:

=============
Curve Framing
=============

`Curve framing <https://en.wikipedia.org/wiki/Frenet%E2%80%93Serret_formulas>`_ refers to the task of constructing a
matrix at any point along a curve. Paya makes this easy with numerous methods on shape, plug and component instances.
Many, like the *matrixAt~* variants, take similar arguments, namely:

.. rubric:: Positional (required)

.. list-table::
    :header-rows: 1

    *   - Parameter
        - Type
        - Description

    *   - Primary axis
        - string, for example '-y'
        - The axis to align to the tangent or aim vector

    *   - Secondary axis
        - string, for example 'x'
        - The matrix axis to map to the up vector

.. rubric:: Keyword (optional)

.. list-table::
    :header-rows: 1

    *   - Parameter
        - Type
        - Default
        - Description

    *   - *upVector* / *upv*
        - vector value or plug
        - ``None``
        - An explicit up vector

    *   - *aimCurve* / *aic*
        - A curve shape or output
        - ``None``
        - A curve to extract 'up' vectors from, similar to a ``curveWarp`` deformer

    *   - *closestPoint* / *cp*
        - boolean
        - ``True``
        - Pull points from *aimCurve* based on proximity

    *   - *squashStretch* / *ss*
        - boolean
        - ``False``
        - Allow stretching of the tangent or aim vector

    *   - *globalScale* / *gs*
        - A scalar plug
        - ``None``
        - Drives baseline scaling

.. note::

    If the *upVector* and *aimCurve* arguments are both omitted, the curve *normal* will be used as the up vector
    (similar to the 'Normal' mode on a motion path). This isn't usually advisable, since the normal will flip as the
    curve changes direction.

Generated matrices can be used to create rivet locators or drive other objects. In the following example, a cube is
'captured' by a matrix at the closest point along a curve:

.. tabs::

    .. tab:: Viewport

        .. figure:: cube_capture.gif
            :align: center

    .. tab:: Paya

        .. code-block:: python

            curve, driven = r.ls(sl=True)
            point = cube.getWorldPosition()

            param = curve.closestParam(point)

            matrix = param.matrix('y', 'x', upVector=[0, 0, 1],
                plug=True, squashStretch=True, closestPoint=False)

            matrix.applyViaOpm(driven,
                worldSpace=True, maintainOffset=True)

.. _curve_distributions:

============================
Distributions, Joint Driving
============================

The curve shape and plug classes include a few distribution methods for points and matrices:
:meth:`~paya.runtime.nodes.NurbsCurve.distributePoints`, :meth:`~paya.runtime.nodes.NurbsCurve.distributeMatrices`
and :meth:`~paya.runtime.nodes.NurbsCurve.distributeAimingMatrices`. All work by-length, meaning that any live (dynamic)
samples will be automatically redistributed as the curve shape changes.

Two higher-level wrappers, :meth:`~paya.runtime.nodes.NurbsCurve.distributeJoints` and
:meth:`~paya.runtime.nodes.NurbsCurve.fitChain` make it easy to draw and drive floating joints or contiguous joint
chains, respectively:

.. tabs::

    .. tab:: Viewport

        .. figure:: chain_fitting.gif
            :align: center

    .. tab:: Paya

        .. code-block:: python

            mainCurve, aimCurve = r.ls(sl=1)
            chain = mainCurve.fitChain(12, 'y', 'x',
                aimCurve=aimCurve, closestPoint=False, plug=True)

.. _length_locking:

==============
Length Locking
==============

Curve lengths can be reduced and increased using :meth:`~paya.runtime.nodes.NurbsCurve.retract` and
:meth:`~paya.runtime.nodes.NurbsCurve.extend`. These are in turn used by
:meth:`~paya.runtime.nodes.NurbsCurve.setLength` to force curve length. Curve extensions default to the 'Extrapolate'
mode of an ``extendCurve`` node. For spine systems, providing an explicit extension vector will give you finer control
over the end tangent. In the following example, this vector is extracted from an end control:

.. tabs::

    .. tab:: Viewport

        .. figure:: length_locking.gif
            :align: center

    .. tab:: Paya

        .. code-block:: python

            curve, control = r.ls(sl=True)
            extensionVector = control.attr('worldMatrix').getAxis('-y')

            length = curve.length() # notice static
            curve.setLength(length, vector=extensionVector)

.. _arcs:

====
Arcs
====

Paya provides two constructors for circular arcs:

-   :meth:`~paya.runtime.nodes.NurbsCurve.createArc` on the :class:`~paya.runtime.nodes.NurbsCurve` shape class
-   :meth:`~paya.runtime.plugs.NurbsCurve.createArc` on the :class:`~paya.runtime.plugs.NurbsCurve` attribute class

Arcs can be drawn from two or three points. To draw a three-point arc that won't disappear with an error when the points
are in-line, pass *guard=True* along with a direction vector:

.. tabs::

    .. tab:: Viewport

        .. figure:: guarded_arc.gif
            :align: center

    .. tab:: Paya

        .. code-block:: python

            locs = r.ls(type='locator')
            points = [loc.attr('worldPosition') for loc in locs]

            r.nodes.NurbsCurve.createArc(
                points, guard=True, directionVector=[0, 0, 1])

=============
Bezier Curves
=============

Bezier curves are a great alternative to NURBS and EP / B-spline curves for rigging. Unlike cubic curves, Bezier control
points (at the anchors) always 'touch' the limit curve and, unlike EP / B-spline curves, moving the anchor points does
not create opposing 'pops' elsewhere.

.. _bezier_clusters:

Paya treats Bezier curves as a subclass of NURBS curves; all functionality for NURBS curves is also available on the
Bezier classes, with relevant modifications: For example, the :meth:`~paya.runtime.nodes.BezierCurve.clusterAll` method
on :class:`~paya.runtime.nodes.BezierCurve` includes an *anchors* / *a* keyword option:

.. tabs::

    .. tab:: Viewport

        .. figure:: bezier_clusters.gif
            :align: center

    .. tab:: Paya

        .. code-block:: python

            bezier = r.PyNode('bezier1')
            bezier.clusterAll(anchors=True)

Bezier-specific sampling methods include :meth:`~paya.runtime.nodes.BezierCurve.matrixAtAnchor`, which performs framing
around anchor points.

Note that some editing methods will return NURBS curve streams, and this may lead to unexpected results when the data
is piped back into a Bezier shape. Rebuild operations in particular (which Maya doesn't allow on Bezier curves
through the GUI) will lead to Bezier degeneration:

.. tabs::

    .. tab:: Viewport

        .. figure:: bezier_degeneration.gif
            :align: center

    .. tab:: Paya

        .. code-block:: python

            bezier.cvRebuild(9)

A way around this is to convert to and from Bezier curves using :meth:`~paya.runtime.nodes.NurbsCurve.toBezier` and
:meth:`~paya.runtime.nodes.NurbsCurve.toNurbs`, respectively. The following example uses the :ref:`procedural 'plug'
workflow <procedural_geo_editing>`:

.. tabs::

    .. tab:: Viewport

        .. figure:: bez_degen_workaround.gif
            :align: center

    .. tab:: Paya

        .. code-block:: python

            stream = bezier.getHistoryPlug(create=True)
            stream = stream.toNurbs().cvRebuild(9).toBezier()
            stream >> bezier.geoInput