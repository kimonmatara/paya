*************
Maths Rigging
*************

==========
Operations
==========

Arithmetic Operators
--------------------

Paya implements a wide range of arithmetic operators, with support for mixing of values, attributes and dimensions. In
general, functionality reserved for PyMEL's data classes has been extended to attributes. Some niche cases, like
elementwise operations across array plugs, are omitted.

All of the following statements are valid, and will generate appropriate node networks:

.. code-block:: python

    loc.translate + 3
    3 + loc.translate
    p.datatypes.Vector([1, 2, 3]) * 'locator1.worldMatrix'

However, the following would error, or yield unexpected results:

.. code-block:: python

    'locator1.translate' + 3
    [0.3, 2.0, 1.0] * 'locator1.worldMatrix'
    3 * [0.3, 2.0, 1.0]
    'locator1.worldMatrix' * 'locator2.worldMatrix'

This is because when both operands are simple Python types, it's impossible to determine the intended Paya (or PyMEL)
method.

Available operators are documented under :doc:`paya/plugtypes` and :doc:`paya/datatypes`.

Point-Matrix Multiplication
---------------------------

PyMEL uses the ``*`` operator both for vector-matrix and point-matrix multiplication. The latter is triggered when
the left operand is a :class:`~pymel.core.datatypes.Point` rather than a :class:`~pymel.core.datatypes.Vector` instance.
Paya extends this behaviour to support matrix attributes:

.. code-block:: python

    point = p.datatypes.Point([0,2,3])
    point * loc.worldMatrix # point * 'locator1.worldMatrix' also works

The above example would configure a ``pointMatrixMult`` node with vectorMultiply set to False.

Additionally, because in Paya :meth:`~paya.plugtypes.Attribute.get` called on ``translate`` channels always returns a
:class:`~pymel.core.datatypes.Point` instance, the following will produce point-matrix multiplication by default:

.. code-block:: python

    loc1.translate.get() * loc2.worldMatrix

    # The following also works
    loc1.translate.get() * 'locator2.worldMatrix'


Paya also supports triple scalar attributes (i.e., ``double3``) as the left operand. However, since Maya doesn't
distinguish between point and vector attributes, ``*`` always treats them as vectors. In such cases you can use a
new ``^`` operator for point-matrix multiplication:

.. code-block:: python

    (loc1.t + loc2.t) ^ loc3.wm # pointMatrixMult.vectorMultiply set to False
    (loc1.t + loc2.t) * loc3.wm # pointMatrixMult.vectorMultiply set to True
    pma.output3D.get() ^ loc3.wm.get() # available on values too


=====================
Working with Matrices
=====================

Maintain Offset
---------------

When developing matrix-based constraints with Paya, you can emulate the ``maintainOffset/mo`` constraint option in
Maya's constraints like this:

.. code-block:: python

    master = p.PyNode('locator1')
    slave = p.PyNode('locator2')

    masterMatrix = master.worldMatrix
    masterMatrix = masterMatrix * masterMatrix.get().inverse() # to identity once
    slavePose = slave.getMatrix(worldSpace=True)
    masterMatrix = slavePose * masterMatrix

    slave.inheritsTransform.set(False)
    masterMatrix >> slave.offsetParentMatrix

Because this is such a common recipe, Paya provides a convenient macro for it,
:meth:`~paya.plugtypes.attributeMath16D.AttributeMath16D.asOffset`:

.. code-block:: python

    (slavePose * master.worldMatrix.asOffset()) >> slave.offsetParentMatrix

For polymorphic parity, the method has also been made available on :class:`~paya.datatypes.matrix.Matrix`.

Filtering
---------

Matrix filtering via ``pickMatrix`` nodes is now available via a
:meth:`~paya.plugtypes.attributeMath16D.AttributeMath16D.pick` method on matrix attributes, also available via the
shorthand ``pk``. The method has also been replicated statically on :class:`~paya.datatypes.matrix.Matrix` objects:

.. code-block:: python

    master.worldMatrix.pick(rotate=True) >> slave.offsetParentMatrix # dynamic
    master.worldMatrix.get().pick(rotate=True) >> slave.offsetParentMatrix # static; note chevrons for value assignment

Both versions also accept a ``default`` argument, allowing you to take omitted fields from a fallback input (or value).
The resulting matrix is correctly recombined according to Maya's transform model, i.e.
``scale * shear * rotate * translate``. This allows you to create 'partial' matrix constraints, somewhat akin to
connecting only certain outputs of a ``decomposeMatrix``:

.. code-block:: python

    fallbackMatrix = p.PyNode('root_XFRM').worldMatrix
    masterMatrix = p.PyNode('locator1').worldMatrix.pk(rotate=True, default=fallbackMatrix)
    masterMatrix >> p.PyNode('locator2').offsetParentMatrix

In the above example, 'locator2' would take rotation from 'locator1', and translate, scale and shear from 'root_XFRM'.

.. _Preventing Unit Conversions:

===========================
Preventing Unit Conversions
===========================

Paya doesn't attempt to account for ``unitConversion`` nodes. Instead, it's written under the assumption that Maya is
configured for native units (namely, centimetres and radians) so that these nodes won't be generated at all, and gives
you a couple of tools to enforce this for blocks you specify.

The first is the :class:`~paya.lib.mathops.NativeUnits` context manager:

.. code-block:: python

    from paya.lib.mathops import NativeUnits # capitalised

    with NativeUnits():
        loc1.rx * loc2.ty

The second is :func:`~paya.lib.mathops.nativeUnits`, a decorator for methods and functions:

.. code-block:: python

    from paya.lib.mathops import nativeUnits # uncapitalised

    @nativeUnits
    def angleMath(loc1, loc2):
        return loc1.rx * loc2.ty

In both cases Maya unit preferences are restored on block exit.

.. note::
    This approach greatly simplifies working with arithmetic operations, but means you will be working with radians rather
    than degrees. If you find degrees more intuitive to inspect, you can use :func:`pymel.util.radians` and
    :func:`pymel.util.degrees` for conversions.

==========================
Miscellaneous Enhancements
==========================

.. _More Useful Query Types:

More Useful Query Types
-----------------------

Paya returns more useful types when :meth:`~paya.plugtypes.attribute.Attribute.get` is called on a variety of attributes.
Specifically:

*   The value of the ``translate`` channel on a transform will always be returned as a
    :class:`~pymel.core.datatypes.Point`

*   The value of the ``rotate`` channel on a transform will always be returned as an
    :class:`~pymel.core.datatypes.EulerRotation`

*   The value of any four-dimensional compound of scalars will always be returned as a
    :class:`~pymel.core.datatypes.Quaternion`

This sets you up better for subsequent mixed-mode operations.

Agnostic Getting / Setting
--------------------------

Paya adds a few enhancements to help develop code where the decision whether to work dynamically or statically
rests with the end-user:

*   :meth:`~paya.plugtypes.attribute.Attribute.get` has a new keyword argument, ``plug / p``, which will return
    the attribute itself if set to True.

*   A new method on attributes, :meth:`~paya.plugtypes.attribute.Attribute.put`, sets a value **or** connects an input
    depending on what's passed.

*   The popular PyMEL double-chevron operator, ``>>``, has accordingly been extended to support values as well as
    attributes as the left operand, making statements like this valid:

    .. code-block:: python

        3.0 >> loc1.tx