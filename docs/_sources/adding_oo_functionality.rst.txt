####################################
Adding Object-Oriented Functionality
####################################

*********
Targeting
*********

Every PyMEL `object <https://en.wikipedia.org/wiki/Object_(computer_science)>`_, whether 'converted' from a string via
:class:`~pymel.core.general.PyNode` or returned by a method such as :meth:`~pymel.core.nodetypes.Transform.getMatrix`,
derives from a Python `class <https://en.wikipedia.org/wiki/Class_(computer_programming)>`_. The class defines the
`methods <https://en.wikipedia.org/wiki/Method_(computer_programming)>`_, or functionality, available on the object.
PyMEL's classes are broadly derived from the Maya API, and organised in a hierarchy with more specific classes at the
bottom and more generic ones at the top.

To determine where to add your custom methods, you must first find out which classes an object inherits from.

Finding Ancestors
-----------------

You may already be familiar with the standard Maya :func:`~pymel.core.general.nodeType` command. When called with
``inheritance=True``, it returns a list of type names:

.. code-block:: python

    import pymel.core as p
    print(p.nodeType('joint1', inherited=True))
    # ['containerBase', 'entity', 'dagNode', 'transform', 'joint']

    # The following also works:
    joint = p.PyNode('joint1')
    print(joint.nodeType(inherited=True))

The most specific type is last on the list, and the most general one one is first. In other words, joints inherit
functionality from transforms, which inherit functionality from dagNodes, and so on.

.. note::
    Some of these types can exist as Maya objects, namely ``joint`` and ``transform``. Others, like ``dagNode``, can't:
    they are `abstract <https://en.wikipedia.org/wiki/Abstract_type>`_ types, existing merely to define functionality that
    will be inherited by their descendants.

Choosing the Right Ancestor
---------------------------

Inspecting a shape node reveals that, like the joint in the previous example, it, too, inherits from ``dagNode``:

.. code-block:: python

    import pymel.core as p
    print(p.nodeType('pCubeShape1', inherited=True))
    # ['containerBase', 'entity', 'dagNode', 'shape', 'geometryShape', 'deformableShape', 'controlPoint', 'surfaceShape', 'mesh']

This suggests that, if you want to make a new method available on all shape-like and transform-like objects
(collecting known in Maya as DAG nodes), you can merely add it to the ``dagNode`` type, rather than duplicating it
across ``joint``, ``transform``, ``mesh`` and so on.

Deeper Inspections
------------------

:func:`~pymel.core.general.nodeType` returns a truncated list of types, and only works on nodes. Here's how to get more
comprehensive information on any PyMEL object, including attributes, components and 'data' objects:

1.  Get a PyMEL instance (i.e., don't start with a string)
2.  Get the class of the instance via its ``__class__`` attribute, or by calling :class:`type`
3.  Access the ``__mro__`` attribute of the class

.. note:: Make sure you are running PyMEL in **unpatched** mode for the following example.

.. code-block:: python

    # Get an instance
    joint = p.PyNode('joint1')

    # Get the class
    cls = joint.__class__ # or: type(joint)

    print(cls.__mro__)
    # (<class 'pymel.core.nodetypes.Joint'>, <class 'pymel.core.nodetypes.Transform'>, <class 'pymel.core.nodetypes.DagNode'>, <class 'pymel.core.nodetypes.Entity'>, <class 'pymel.core.nodetypes.ContainerBase'>, <class 'pymel.core.nodetypes.DependNode'>, <class 'pymel.core.general.PyNode'>, <class 'pymel.util.utilitytypes.proxyClass.<locals>.Proxy'>, <class 'object'>)

Note these differences from :func:`~pymel.core.general.nodeType`:

*   The order is reversed, with the most specific class on the left, and the most general one on the right
*   Instead of strings, the list contains actual classes; these can be further inspected using :func:`help`, :func:`dir`
    and :mod:`inspect`
*   More 'esoteric' types, such as :class:`~pymel.core.nodetypes.DependNode`, are included

The following all work too:

.. code-block:: python

    print(joint.translate.__class__.__mro__) # attributes
    print(cube.vtx[2].__class__.__mro__) # components
    print(joint.getMatrix().__class__.__mro__) # data

.. note::

    ``__mro__`` stands for **method resolution order**; it's a list of every class Python will visit to retrieve a
    method you have requested. For example, when you call :meth:`~pymel.core.nodetypes.DagNode.getParent` on a group
    node, the method is not retrieved from :class:`~pymel.core.nodetypes.Transform`; it is in fact defined inside
    the more general class :class:`~pymel.core.nodetypes.DagNode`, and this is why it's also available on shapes.

Paya Inheritance
----------------

When Paya patches PyMEL, it inserts a custom ancestor for almost every PyMEL class into the inheritance stack:

.. code-block:: python

    import paya.runtime as r
    # PyMEL has been patched successfully.

    joint = r.PyNode('joint1')
    print(joint.__class__.__mro__)
    # (<class 'paya.nodetypes.joint.Joint'>, <class 'pymel.core.nodetypes.Joint'>, <class 'paya.nodetypes.transform.Transform'>, <class 'pymel.core.nodetypes.Transform'>, <class 'paya.nodetypes.dagNode.DagNode'>, <class 'pymel.core.nodetypes.DagNode'>, <class 'paya.nodetypes.entity.Entity'>, <class 'pymel.core.nodetypes.Entity'>, <class 'paya.nodetypes.containerBase.ContainerBase'>, <class 'pymel.core.nodetypes.ContainerBase'>, <class 'paya.nodetypes.dependNode.DependNode'>, <class 'pymel.core.nodetypes.DependNode'>, <class 'pymel.core.general.PyNode'>, <class 'pymel.util.utilitytypes.proxyClass.<locals>.Proxy'>, <class 'object'>)

This overcomes the limitations of PyMEL's
`virtual classes <https://github.com/LumaPictures/pymel/blob/master/examples/customClasses.py>`_ system in the
following ways:

*   PyMEL classes inherit from Paya classes, ensuring that functionality trickles down correctly
*   More classes can be customised, including component, attribute, data and abstract types

Attribute Subtypes
------------------

PyMEL provides only one class for attribute instances, :class:`~pymel.core.general.Attribute`. Paya splits this into
multiple subtypes, themselves derived from the Maya API. Here's an example inspection of a ``translate`` channel,
showing potential hooks for 3D arithmetic methods:

.. code-block:: python

    # Unpatched
    print(r.node('joint1').translate.__class__.__mro__)
    (<class 'pymel.core.general.Attribute'>, <class 'pymel.core.general.PyNode'>, <class 'pymel.util.utilitytypes.proxyClass.<locals>.Proxy'>, <class 'object'>)

    import paya.runtime as r
    # PyMEL patched succesfully.

    print(r.node('joint1').translate.__class__.__mro__)
    (<class 'paya.plugtypes.attribute3Double.Attribute3Double'>, <class 'paya.plugtypes.attributeMath3D.AttributeMath3D'>, <class 'paya.plugtypes.attributeMath.AttributeMath'>, <class 'paya.plugtypes.attribute.Attribute'>, <class 'pymel.core.general.Attribute'>, <class 'pymel.core.general.PyNode'>, <class 'pymel.util.utilitytypes.proxyClass.<locals>.Proxy'>, <class 'object'>)

*********
Authoring
*********

Template Classes
----------------

Custom Paya classes are derived from **template classes**. Each template class receives its own module, and the module
name is the uncapitalized name of the class it contains. These modules live inside :doc:`paya/nodetypes`,
:doc:`paya/plugtypes`, :doc:`paya/comptypes` and :doc:`paya/datatypes`. So, to add methods to the
:class:`pymel.core.nodetypes.Transform` class, you would work inside ``paya/nodetypes/transform.py``.

Inside the module, a class with basic content can be started like this:

.. code-block:: python

    class Transform:
        def printOrientationInfo(self):
            print("Rotate: {}".format(self.rotate.get()))

That's it. (No, really!)

Template classes should never be imported or used directly. They merely define content used to construct 'final' classes
which can be accessed via the :ref:`class pools` on :mod:`paya.runtime`. This simplifies authoring and improves
stability, because inheritance is dealt with separately (an example of `aspect-oriented programming
<https://en.wikipedia.org/wiki/Aspect-oriented_programming>`_).

.. note::

    For experienced Python programmers, template classes have one drawback: :class:`super` cannot be
    used to overload superclass methods. Instead, the appropriate parent must be sourced via the class pools so that
    that the explicit form can be used:

    .. code-block:: python

        import paya.runtime as r

        class Joint:
            def printOrientationInfo(self):
                r.nodes.Transform.printOrientationInfo(self)
                print("Joint orient: {}".format(self.jointOrient.get()))

.. note::

    Where a template module doesn't exist, Paya auto-generates an empty class for insertion into the inheritance
    stack.

Adding Methods
--------------

Methods can be added to classes in standard Python form:

.. code-block:: python
    :caption: Source

    import paya.runtime as r
    from functools import reduce

    class Transform:

        # Instance method
        def dropToFloor(self):
            self.ty.set(0)

        # Class method
        @classmethod
        def createAtMatrix(cls, matrix):
            out = cls.createNode()
            out.setMatrix(matrix)
            return out

        # Static method
        @staticmethod
        def parentToEachOther(*transforms):
            reduce(
                lambda x, y : r.parent(y, x),
                transforms
            )

.. code-block:: python
    :caption: Execution

    import paya.runtime as r

    loc1 = r.PyNode('locator1')
    loc1.ty.set(10)
    loc1.dropToFloor()
    print(loc1.ty.get())
    # 0.0

    loc2 = r.nodes.Transform.createAtMatrix(loc1.getMatrix())

    r.nodes.Transform.parentToEachOther(loc1, loc2)
    print(loc2.getParent())
    # locator1


Adding Operators
----------------

Python magic ('dunder') methods are fully supported. Here's an excerpt from the bundled template classes, showing the
implementation for the new ``^`` operator in :class:`~paya.plugtypes.attributeMath3D.AttributeMath3D`:

.. code-block:: python

    def __xor__(self, other):
        node = r.nodes.PointMatrixMult.createNode()
        self >> node.attr('inPoint')
        other >> node.attr('inMatrix')
        return node.attr('output')

*********
Reloading
*********

To use your new methods you must first **reload the class pools**. You can do this with
:meth:`~paya.runtime.Runtime.rehash`. Note that this doesn't update any existing PyNode instances. For this  reason,
when testing iteratively, it makes sense to just keep a call to :meth:`~paya.runtime.Runtime.rehash` at the top of your
Script Editor tab:

.. code-block:: python

    import paya.runtime as r
    r.rehash()
    joint = r.PyNode('joint1')

    # At this point, switch to your editor and add a playThePiano() method that will print 'Plink plonk!'
    joint.playThePiano()

    # The first time, this will fail with:
    # AttributeError: nt.Joint('joint1') has no attribute or method named 'playThePiano' #

    # But the second time you execute the tab contents, you'll get:
    # Plink plonk!

.. _Bracketing:

**********
Bracketing
**********

Recall that once :mod:`paya.runtime` is imported, or :meth:`~paya.runtime.Runtime.start` is called, PyMEL will continue
to return Paya classes until you call :meth:`~paya.runtime.Runtime.stop`. For this reason, classes bundled with standard
Paya releases never override standard PyMEL methods,  otherwise external pipeline code that relies on unmodified PyMEL
might break.

If you're using a heavily customised version of Paya, you should consider 'bracketing' your build scripts with
:meth:`~paya.runtime.Runtime.stop` and :meth:`~paya.runtime.Runtime.start` for safety:

.. code-block:: python

    import paya.runtime as r
    r.stop() # Reverse patching

    import your_studio_pipeline # or whatever your studio calls it

    # Run pipeline scripts without patching
    your_studio_pipeline.initAsset()
    your_studio_pipeline.importGeo()

    # Start patching again
    r.start()

    # Run your build script, and reverse patching even if errors were
    # encountered

    try:
        import your_build_module
        your_build_module.buildTheRig()

    finally:
        r.stop()